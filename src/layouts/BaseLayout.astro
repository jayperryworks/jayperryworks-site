---
// assets
import '@styles/base/reset.css';
import '@styles/base/type.css';
import '@styles/tokens/borders.css';
import '@styles/tokens/color.css';

// components
import MainNav from '@components/navigation/MainNav.astro';
import MainFooter from '@components/navigation/MainFooter.astro';

// types
import type {
	ColorRoles,
	CSSVariable,
	HexColor,
	HSLColor,
	Theme,
} from '@lib/types';

import type { SEOContent } from '@lib/types';

export interface Props {
	headerOverlay?: boolean;
	pageTitle?: string;
	path?: string;
	seo?: SEOContent;
	theme?: Partial<Theme>;
}

export type ThemeTokens = Partial<Record<`color-${ColorRoles}`, HexColor | HSLColor | CSSVariable>>;

// props and data
const {
	pageTitle,
	headerOverlay = false,
	path = 'home',
	theme,
	seo = {},
} = Astro.props as Props;

const SITE_TITLE = 'Jay Perry';
const title = pageTitle ? `${SITE_TITLE} | ${pageTitle}` : SITE_TITLE;
// const canonicalURL = `${import.meta.env.SITE.slice(0, -1)}${}`;

// if a theme has been passed in, replace the default color tokens with the theme values
function themeReducer(
	result: ThemeTokens,
	role: ColorRoles
): ThemeTokens {
	if (theme[role]) result[`color-${role}`] = theme[role];
	return result;
}

const themeTokens: ThemeTokens = theme ? Object.keys(theme).reduce(themeReducer, {}) : {};
---

<script>
	// Add a class to the body element to confirm JS is available
	// -> used by the CSS for styling JS-dependent elements
	let featureClasses = ['js'];
	// Add a class if the browser/device supports touch
	if ("ontouchstart" in document.body) featureClasses.push('touch');
	document.body.className = featureClasses.join(' ');


	// when an el intersects, mark it as visible
	// if an element is visible, and the previous element is done, start its reveal
	// when the reveal finishes, start the next reveal
	// if the next element isn't visible yet, wait

	// 2 events:
	// -> an element is visible
	// -> an element is finished revealing

	type RevealedElement = {
		DOMRef: Element,
		isVisible?: boolean,
		revealed?: boolean,
	};

	const REVEAL_DURATION = 4;

	const revealedElements: RevealedElement[] = Array.from(document.querySelectorAll('[data-revealed]'))
		.map((element) => ({
			DOMRef: element,
			isVisible: false,
			revealed: false,
		}));

	function getElement(element: Element): RevealedElement {
		return revealedElements.find((el) => el.DOMRef === element);
	}

	function setVisible(element: Element, state: boolean = false) {
		getElement(element).isVisible = state;
		console.log('intersecting:', getElement(element));

		if (state) {
			startReveal(element);
		}
	}

	function setReveal(element: Element, state: boolean = false) {
		getElement(element).revealed = state;
		console.log('revealed:', getElement(element));

		if (state) {
			const index = revealedElements.indexOf(getElement(element));
			revealedElements[index + 1] && startReveal(revealedElements[index + 1].DOMRef);
		}
	}

	function startReveal(element: Element) {
		const current = getElement(element);
		const currentIndex = revealedElements.indexOf(current);

		if (currentIndex > 0 && revealedElements[currentIndex - 1].revealed) {
			if (current.isVisible) {
				console.log('hello');
				current.DOMRef.dataset.revealed = true;
				setTimeout(() => { setReveal(element, true) }, REVEAL_DURATION * 1000);
			}
		}

		return;
	}

	if ('IntersectionObserver' in window) {
		const revealObserver = new IntersectionObserver(
			(entries) => entries.forEach((entry) => {
				if (entry.isIntersecting) {
					setVisible(entry.target, true);
				}
			}),
			{
				threshold: 0,
			}
		);

		revealedElements.forEach((element) => {
			revealObserver.observe(element.DOMRef);
		})
	}
</script>

<html lang="en">
	<head>
		<meta charset='utf-8'>
		<meta name='viewport' content='width=device-width, initial-scale=1.0'>

		<title>{title}</title>

		<!-- favicon -->
		<link rel="icon" hDOMRef="/favicon.ico" sizes="any">
		<link rel="icon" hDOMRef="/icon.svg" type="image/svg+xml">
		<link rel="apple-touch-icon" hDOMRef="/apple-touch-icon.png">
		<link rel="manifest" hDOMRef="/manifest.webmanifest">

		<!-- social/seo markup -->
		<!-- hat tip to https://meiert.com/en/blog/minimal-social-markup/ -->
		<meta name="twitter:card" content={seo.image ? 'summary_large_image' : 'summary'}>
		<meta property="og:title" content={seo.title || title}>
		<meta property="og:site_name" content={SITE_TITLE}>
		<meta property="og:url" content={new URL(Astro.url.pathname, Astro.site)}>
		<meta property="og:locale" content="en_US">
		<meta property="og:author" content="Jay Perry">
		{seo.description && <meta property="og:description" name="description" content={seo.description}>}
		{(seo.image) && (
			<meta property="og:image" content={seo.image}>
			<meta property="og:image:alt" content={seo.imageAlt}>
		)}
	</head>

	<body class="no-js no-touch">
		<MainNav segment={path} overlay={headerOverlay} />
		<main>
			<slot />
		</main>
		<MainFooter class="footer" />
	</body>
</html>

<!-- set the page theme as root custom properties to override the default tokens -->
<style define:vars={themeTokens} is:global></style>

<style>
	body {
		background-color: var(--color-bg);
		color: var(--color-primary);
		display: grid;
		grid-template-rows: auto 1fr auto;
		min-height: 100vh;
		position: relative;
	}

	:global(.js [data-revealed]) {
		transition: opacity 4s ease;
	}

	:global(.js [data-revealed='false']) {
		opacity: 0;
	}

	:global(.js [data-revealed='true']) {
		opacity: 1;
	}
</style>
