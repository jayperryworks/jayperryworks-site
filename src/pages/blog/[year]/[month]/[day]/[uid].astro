---
// styles & assets
import '@styles/tokens/color.css';
import '@styles/tokens/contentWidth.css';
import '@styles/tokens/spacing.css';
import '@styles/tokens/type.css';
import '@styles/utilities/borders.css';
import '@styles/utilities/contentWidth.css';
import '@styles/utilities/type.css';
import '@styles/utilities/visibility.css';
import externalLink from '@icons/external-link.svg?raw';

// helpers
import { format } from 'date-fns';
import { blogPost as permalink, fetchLinks } from '@lib/routes';
import { sentenceCase } from '@lib/stringHelpers';
import * as prismicHelpers from '@prismicio/helpers';
import prismic from '@lib/prismic';

// components
import Layout from '@layouts/BaseLayout.astro';
import BlockList from '@components/BlockList.astro';
import Button from '@components/elements/Button.astro';
import Heading from '@components/blocks/Heading.astro';
import ReadNextLink from '@components/navigation/ReadNextLink.astro';
import ThreadNav from '@components/navigation/ThreadNav.astro';
import ThreadNavItem from '@components/navigation/ThreadNavItem.astro';

// types
import type {
	LinkField,
	PrismicDocumentWithUID,
	RichTextField,
	Slice,
	Tags,
	TitleField,
	DevelopmentStage,
} from '@prismicio/types';

import type {
	PaginationLink,
	SEOContent,
} from '@lib/types';

type Thread = {
	posts: PrismicDocumentWithUID[],
	uid: string,
	description?: RichTextField,
	title?: TitleField,
};

type PublicationDates = {
	publication: Date,
	posted?: Date,
	updated?: Date,
};

export interface Props {
	body: Array<Slice>;
	date: PublicationDates;
	title: TitleField;
	link?: LinkField;
	next?: PaginationLink;
	seo?: SEOContent;
	stage?: DevelopmentStage;
	subtitle?: TitleField;
	tags?: Tags;
	thread?: Thread;
}

export async function getStaticPaths() {
 	const posts = await prismic.getAllByType('blog_post', {
		fetchLinks,
 		orderings: {
 			field: 'my.blog_post.metadata',
 			direction: 'desc',
 		},
		graphQuery: `
			{
				blog_post {
					...blog_postFields
					thread {
						...on blog_series {
							uid
							title
							description
						}
					}
				}
			}
		`,
 	});

 	return posts.map(({
		uid,
		tags,
		data,
		first_publication_date,
		last_publication_date,
	}, index) => {
		const date = prismicHelpers.asDate(data.date);
		const nextPost = posts[index + 1];
		const { data: thread } = data.thread;

		// If this post is part of a thread, grab other posts that also belong to the thread
		// -> these will be ordered by data, because the `posts` array already is
		if (thread) {
			thread.posts = posts.filter((post) => {
				return post.data?.thread?.data?.uid === thread.uid;
			}).reverse();
		}

 		return {
 			params: {
 				year: format(date, 'yyyy'),
 				month: format(date, 'MM'),
 				day: format(date, 'dd'),
 				uid,
 			},
 			props: {
 				...data,
				stage: data.stage || 'Note',
				date: {
					publication: date,
					posted: new Date(first_publication_date),
					updated: new Date(last_publication_date),
				},
 				tags,
				link: prismicHelpers.asLink(data.link),
 				next: nextPost && {
					title: nextPost.data.title,
					subtitle: nextPost.data.subtitle,
					path: permalink(nextPost),
				},
				seo: {
					description: data.seo_description || data.description,
					image: data.seo_image?.url,
					imageAlt: data.seo_image?.alt,
					title: data.seo_title || prismicHelpers.asText(data.title),
				},
				thread,
 			},
 		};
 	});
}

const { uid } = Astro.params;

const {
	body,
	date,
	link,
	next,
	seo,
	thread,
	subtitle,
	tags,
	title,
	stage,
} = Astro.props as Props;
---

<Layout
	pageTitle={prismicHelpers.asText(title)}
	path="blog"
	{seo}
>
	<article>
		<header>
			<Heading level={1}>{prismicHelpers.asText(title)}</Heading>
			{prismicHelpers.isFilled.title(subtitle) && (
				<Heading
					class="subtitle"
					subheading
				>
					{prismicHelpers.asText(subtitle)}
				</Heading>
			)}

			<dl class="metadata">
				<div class="metadata-item">
					<dt class="hide-visually">Development stage:</dt>
					<dd>{stage}</dd>
				</div>
				<div class="metadata-item">
					<dt class="hide-visually">Published:</dt>
					<dd>
						<time datetime={date.publication}>
							{format(date.publication, 'MMMM dd, yyyy')}
						</time>
					</dd>
				</div>
				{date.posted !== date.updated && (
					<div class="metadata-item">
						<dd>Last updated:</dd>
						<dt>
							<time datetime={date.updated}>
								{format(date.updated, 'MMMM dd, yyyy')}
							</time>
						</dt>
					</div>
				)}
			</dl>

			{thread && (
				<ThreadNav
					title={thread.title && prismicHelpers.asText(thread.title)}
					description={thread.description &&prismicHelpers.asText(thread.description)}
					class="content-width"
				>
					{thread.posts.map((post) => (
						<ThreadNavItem
							current={post.uid === uid}
							date={post.data.metadata}
							href={permalink(post)}
							label={prismicHelpers.asText(post.data.title)}
						/>
					))}
				</ThreadNav>
			)}
		</header>


		<BlockList {body} showLedeStyle />

		{link && (
			<footer class="link">
				<Button
					href={link}
					iconRight={externalLink}
					target="_blank"
				>
					Direct link
				</Button>
			</footer>
		)}
	</article>

	<!-- pagination nav -->
	{next && (
		<nav>
			<section class="nav-wrapper tags">
				<h2 class="type-role-accent type-scale-epsilon">Filed&nbsp;under:</h2>
				<ul class="tag-list type-role-accent">
					{tags.map((tag) => (
						<li>
							<a href={`/blog/tags/${tag}/`}>{sentenceCase(tag)}</a>
						</li>
					))}
				</ul>
			</section>
			<section class="nav-wrapper">
				<ReadNextLink link={next.path}>
					<Fragment slot="eyebrow">Next post:</Fragment>
					<Fragment slot="title">{prismicHelpers.asText(next.title)}</Fragment>
				</ReadNextLink>
			</section>
		</nav>
	)}
</Layout>

<style>
	article {
		padding-block: var(--space-xwide);
	}

	header {
		padding-inline: var(--space-outside);
		margin-inline: auto;
		max-width: var(--content-width-xwide);
		padding-block-end: var(--space-wide);
		text-align: center;
	}

	header > :global(* + *) {
		margin-block-start: var(--space-medium);
	}

	header :global(.subtitle) {
		margin-block-start: 0;
		padding-block-start: var(--space-xxnarrow);
	}

	.metadata {
		--gap: 0.5em;

		color: var(--color-secondary);
		display: inline-block;
		font-family: var(--type-font-accent);
		font-size: var(--type-scale-zeta);
		font-weight: 300;
		list-style: none;
	}

	.metadata-item {
		align-items: center;
		display: flex;
		flex-wrap: wrap;
		gap: 0 var(--gap);
		justify-content: center;
		position: relative;
	}

	@media screen and (min-width: 37em) {
		.metadata {
			display: inline-flex;
			gap: var(--gap);
			justify-content: center;
		}

		.metadata-item + .metadata-item::before {
			content: '\2022';
			display: inline-block;
			font-size: 1.5;
			font-weight: bold;
			line-height: 0.5;
		}
	}

	.link {
		margin-inline: auto;
		max-width: var(--content-width-default);
		padding-block-start: var(--space-wide);
	}

	.thread-link[aria-current='page'] {
		color: var(--color-highlight);
		text-decoration: none;
	}

	footer {
		margin-inline: auto;
		max-width: var(--content-width-default);
		padding-block-start: var(--space-xwide);
	}

	.tags {
		display: flex;
		align-items: baseline;
		gap: 0.25em;
		flex-wrap: wrap;
	}

	@media screen and (min-width: 30em) {
		.tags {
			gap: var(--space-xnarrow);
			flex-wrap: nowrap;
		}
	}

	.tag-list {
		list-style: none;
		padding-inline-start: 0;
		padding-block-start: var(--space-xxnarrow);
		margin: 0;
		display: flex;
		gap: 0.5em;
		flex-wrap: wrap;
		align-items: baseline;
	}


	.tag-list li {
		font-size: 0; /* kill whitespace margins */
	}

	.tag-list li::after {
		content: ', ';
		margin-inline-start: 0.1em;
		font-size: var(--type-scale-epsilon);
	}

	.tag-list li:last-child::after {
		content: '';
	}

	.tag-list a {
		font-size: var(--type-scale-epsilon);
	}

	nav {
		padding-block-end: var(--space-xwide);
		padding-inline: var(--space-outside);
	}

	.nav-wrapper {
		margin-inline: auto;
		max-width: var(--content-width-default);
		border-top: var(--border-default);
		padding-block-start: var(--space-wide);
	}

	.nav-wrapper + .nav-wrapper {
		margin-block-start: var(--space-wide);
	}
</style>
