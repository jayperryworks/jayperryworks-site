---
// assets
import '@styles/tokens/contentWidth.css';
import '@styles/tokens/spacing.css';

// utilities
import { convertHexToHSLObject, convertHSLObjectToHSL } from '@lib/colorHelpers';
import { format } from 'date-fns';
import * as prismicHelpers from '@prismicio/helpers';
import prismic from '@lib/prismic';

// components
import Layout from '@layouts/BaseLayout.astro';
import BlockList from '@components/BlockList.astro';
import Callout from '@components/elements/Callout.astro';
import Heading from '@components/blocks/Heading.astro';
import MainFooter from '@components/navigation/MainFooter.astro';
import MainNav from '@components/navigation/MainNav.astro';
import ReadNextLink from '@components/navigation/ReadNextLink.astro';
import SequenceNav from '@components/navigation/SequenceNav.astro';
import SequenceNavItem from '@components/navigation/SequenceNavItem.astro';

// types
import type {
	Align,
	Theme,
	ThemeData,
} from '@lib/types';

import type { Props as SequenceNavItemProps } from '@components/navigation/SequenceNavItem.astro';
import type { Action as CalloutAction } from '@components/elements/Callout.astro';
import type { RichTextField, TitleField } from '@prismicio/types';

export interface SequenceNavItemData extends SequenceNavItemProps {
	title: TitleField;
}

type Callout = {
	title: TitleField,
	description: RichTextField,
	actions?: CalloutAction[],
}

// Using 'nested pagination' to generate 'chapter' pages for each longform project
// -> https://docs.astro.build/en/core-concepts/routing/#nested-pagination
export async function getStaticPaths({ paginate }) {
	// query all longform projects
	// -> use graphQuery to fetch linked Chapter data for each project
	const projectsResponse = await prismic.getAllByType('longform', {
		orderings: {
			field: 'my.longform.date',
			direction: 'desc',
		},
		graphQuery: `
			{
				longform {
					...longformFields
					chapters {
						chapter {
							...on longform_chapter {
								...longform_chapterFields
							}
						}
					}
				}
			}
		`,
	});


	// loop over each project and create a massaged list of chapters to be paginated
	return projectsResponse.flatMap(({ uid, data }) => {
		const year = format(prismicHelpers.asDate(data.date), 'yyyy');

		const callouts = data.body.map(({ primary, items }) => ({
			title: primary.heading,
			description: { prismicText: primary.description },
			actions: items.map(({ call_to_action_label: label, link }) => ({ label, link, })),
		}));

		const chapters = data.chapters.map(({ chapter }) => {
			const {
				title,
				subtitle,
				highlight_color: highlight,
				primary_foreground_color: primary,
				secondary_foreground_color: secondary,
				background_color: bg,
				body,
			} = chapter.data;

			return {
				uid,
				title,
				subtitle,
				body,
				callouts,
				project: {
					uid,
					title: data.title,
					subtitle: data.subtitle,
					chapterLabel: data.chapter_label,
					chapterList: data.chapters.map(({ chapter }) => chapter.data.title),
				},
				seo: {
					description: data.seo_description,
					image: data.seo_image?.url,
					imageAlt: data.seo_image?.alt,
					title: data.seo_title,
				},
				theme: {
					bg,
					highlight,
					primary,
					secondary,
				},
			};
		});

		// one chapter per page under the given project params
		const pages = paginate(chapters, {
			pageSize: 1,
			params: { year, uid },
		});

		return pages;

	});
}

const {
	year,
	uid,
} = Astro.params;

const {
	url,
	data,
	currentPage,
	lastPage,
} = Astro.props.page;

const {
	body,
	project,
	seo,
	subtitle,
	theme,
	title,
	callouts,
} = data[0];

// if no title was given for SEO content, make a default one using the page data above
// -> locating it down here instead of in the pagination function above because currentPage is accessible from here
if (!seo.title) seo.title = `${prismicHelpers.asText(project.title)}, Part ${currentPage}: ${prismicHelpers.asText(title)}`;

// build a theme for this page based on the data from Prismic
function generatePageTheme(): Partial<Theme> {
	if (theme?.bg) {
		// convert the theme values to objects
		let generatedTheme: Partial<ThemeData> = Object.keys(theme).reduce((result, role) => {
			if (theme[role]) {
				result[role] = convertHexToHSLObject(theme[role]);
			}
			return result;
		}, {});

		// if these colors aren't specified in the Prismic data, derive each from the bg color
		const themeFallbacks = {
			primary: 25,
			secondary: 35,
			border: (generatedTheme?.bg?.l - 20) || 40,
			shadow: (generatedTheme?.bg?.l - 15) || 10,
			well: (generatedTheme?.bg?.l - 5) || 60,
			island: (generatedTheme?.bg?.l + 5) || 70,
		};

		Object.keys(themeFallbacks).forEach((role) => {
			if (!generatedTheme[role]) {
				generatedTheme[role] = {
					...generatedTheme.bg,
					l: themeFallbacks[role],
				}
			}
		});

		return Object.keys(generatedTheme).reduce((result, role): Partial<Theme> => {
			result[role] = convertHSLObjectToHSL(generatedTheme[role]);
			return result;
		}, {});
	}

	return {};
}

function sequenceNavItemAlign(index: number): Align {
	if (index === 0) return 'start';
	if (index === lastPage - 1) return 'end';
	return 'center';
}

// list of chapter links for the SequenceNav at the top and bottom of the page
const sequenceNavItems = project.chapterList.map(
	(title: TitleField, index: number): SequenceNavItemData => ({
		title,
		href: `/longform/${year}/${uid}/${index + 1}`,
		complete: currentPage > index + 1,
		current: currentPage === index + 1,
		tooltipAlign: sequenceNavItemAlign(index),
	})
);

const nextChapter = project.chapterList[currentPage] ? {
	title: project.chapterList[currentPage],
	number: currentPage + 1,
	href: url.next,
} : null;

---

<Layout
	pageTitle={prismicHelpers.asText(project.title)}
	theme={generatePageTheme()}
	{seo}
>
	<MainNav segment={uid} />
	<main>
		<article>
			<!-- titling -->
			<header class="headline">
				<div class="wrapper wide">
					<!-- project title -->
					<Heading level={1} text={project.title} />
					{project.subtitle && <Heading level={1} subheading text={project.subtitle} />}
					<!-- sequence nav -->
					<div class="header-nav | wrapper">
						<SequenceNav>
							{sequenceNavItems.map((item) => (
								<SequenceNavItem {...item}>{prismicHelpers.asText(item.title)}</SequenceNavItem>
							))}
						</SequenceNav>
					</div>
					<!-- chapter title -->
					<Heading level={3} subheading>{`${project.chapterLabel} ${currentPage}`}</Heading>
					<Heading level={2} class="header-chapter" text={title} />
					{subtitle && <Heading level={3} class="header-chapter" subheading text={subtitle} />}
				</div>
			</header>

			<!-- body -->
			<BlockList {body} showLedeStyle />
		</article>

		<!-- sequence nav -->
		<nav class="footer-nav">
			<div class="wrapper">
				<SequenceNav>
					{sequenceNavItems.map((item) => (
						<SequenceNavItem {...item} next={item.href === url.next}>
							{prismicHelpers.asText(item.title)}
						</SequenceNavItem>
					))}
				</SequenceNav>
				<div class="next">
					{nextChapter
						? <ReadNextLink
								align="end"
								class="next"
								eyebrowSize="gamma"
								link={nextChapter.href}
								titleSize="beta"
							>
								<Fragment slot="eyebrow">{`${project.chapterLabel} ${currentPage + 1}`}</Fragment>
								<Fragment slot="title">{prismicHelpers.asText(nextChapter.title)}</Fragment>
							</ReadNextLink>
						: <aside class="end | type-role-display type-scale-gamma">
								The end
							</aside>
					}
				</div>
			</div>
		</nav>
	</main>

	<!-- Callouts -->
		{callouts?.length > 0 && (
			<div class="support">
				{callouts.map((callout: Callout) => (
					<Callout
						{...callout}
						class="support-box"
					/>
				))}
			</div>
		)}
		<MainFooter />
</Layout>

<style>
	article {
		display: flex;
		flex-direction: column;
		gap: var(--space-xwide);
		padding-block: var(--space-xwide);
	}

	.headline {
		text-align: center;
	}

	.headline,
	.footer-nav {
		padding-inline: var(--space-outside);
	}

	.wrapper {
		margin-inline: auto;
		max-width: var(--content-width-default);
	}

	.wrapper.wide {
		max-width: var(--content-width-wide);
	}

	.header-nav {
		padding-block: var(--space-wide);
		margin-inline: auto;
		max-width: var(--content-width-default);
	}

	.header-chapter {
		padding-block-start: var(--space-xxnarrow);
	}

	.footer-nav {
		padding-block-end: var(--space-xwide);
	}

	.next {
		padding-block-start: var(--space-wide);
	}

	.end {
		text-align: end;
		font-style: italic;
		color: var(--color-secondary);
	}

	.support {
		padding-inline: var(--space-outside);
		padding-block-end: var(--space-xwide);
	}

	.support-box {
		max-width: var(--content-width-default);
		margin-inline: auto;
	}
</style>
