---
// assets
import '@styles/tokens/spacing.css';
import '@styles/tokens/type.css';

// components
import Block from '@components/Block.astro';

// utils
import blockTypes from '@lib/blocks';

// types
import type { Block as BlockType } from '@lib/types';
import type { SliceZone } from '@prismicio/types';

export interface Props {
	body: SliceZone;
	showLedeStyle?: boolean;
	class?: string;
	numbered?: boolean;
}

const {
	body,
	class: className = '',
	numbered = false,
	showLedeStyle = false,
} = Astro.props as Props;

// assign a class to certain block types to determine spacing between sibling blocks
function getBlockClass(type: string, displayMode: string = 'flow'): string {
	const classes = {
		passage: 'text',
		blockQuote: 'text',
		heading: 'heading',
		aside: 'text',
	};

	if (classes[type]) {
		return `${classes[type]} ${displayMode}`;
	}

	return displayMode;
}

// if the page body has a 'lede' (intro) paragraph,
// add a 'lede' class to the first passage that appears in the list of blocks
function getLedeClass(block: BlockType):string {
	if (showLedeStyle) {
		const firstPassage = sectionList[0].blocks.find((block: BlockType) => {
			return block.type === 'passage';
		});
		return (block === firstPassage) ? 'lede' : '';
	}
}

// --- build an array of blocks, sorted into sections ---
const sectionList = body.reduce((result: Array<any>, slice: Slice) => {
	const {
		slice_type: type,
		primary,
	} = slice;

	// if the block is a section, then add a new section to the array
	if (type === 'sectionStart') {
		result.push({
			uid: primary.uid,
			numbered: (primary.numbered || false),
			blocks: [],
		});
		return result;
	}

	// if the first blocks are outside a section, then make a generic/empty 'section'
	if (result.length === 0 && type !== 'sectionStart') {
		result.push({ blocks: [] });
	}

	// add the block object to the last 'section' array item
	// if it matches one of the available types
	if (blockTypes[type]) {
		const section = result[result.length - 1];
		const block = blockTypes[type](slice);
		// if the blocklist or section is marked as numbered, add a number prop to the block
		block.number = (numbered || section.numbered) && (section.blocks.length + 1);
		section.blocks.push(block);
	}
	return result;
}, []);

const classList = [
	'block-list',
	className,
].join(' ');
---

<div class={classList}>
	{sectionList.map(({ uid, blocks }) => (
		uid
			? <section id={uid}>
					{blocks.map((block) => (
						<Block
							class={[
								getBlockClass(block.type, block.displayMode),
								getLedeClass(block),
							].join(' ')}
							{block}
						/>
					))}
				</section>
			: blocks.map((block) => (
				<Block
					class={[
						getBlockClass(block.type, block.displayMode),
						getLedeClass(block),
					].join(' ')}
					{block}
				/>
			))
	))}
</div>

<style>
	.block-list > :global(* + *) {
		padding-block-start: var(--space-wide);
	}

	/* --- spacing between blocks with different display modes --- */
	.block-list > :global(.flow + .slide) {
		margin-block-start: var(--space-xwide);
	}

	/* --- spacing between different types of blocks --- */
	.block-list :global(.heading + .text) {
		padding-block-start: var(--space-narrow);
	}

	/* when two sections of type follow one another, add "invisible" spacing between so they feel like one continuous flow of text */
	.block-list :global(.text + .text) {
		padding-block-start: var(--space-medium);
	}

	/* --- 'lede' (intro copy) styling --- */
	.lede :global(p:first-child) {
		font-size: var(--type-scale-delta);
		font-family: var(--type-font-display);
	}
</style>
