---
// assets
import '@styles/tokens/spacing.css';
import '@styles/tokens/type.css';

// utils
import { camelCase } from 'change-case';
import * as prismicHelpers from '@prismicio/helpers';

// components
import Block from '@components/Block.astro';

// types
import type { Block as BlockType } from '@lib/types';
import type { Slice, ImageField } from '@prismicio/types';

export interface Props {
	body: Slice[];
	showLedeStyle?: boolean;
	class?: string;
}

const {
	body,
	showLedeStyle = false,
	class: className = '',
} = Astro.props as Props;

// assign a class to certain block types to determine spacing between sibling blocks
function getBlockClass(type: string): string {
	const classes = {
		passage: 'text',
		blockQuote: 'text',
		heading: 'heading',
		aside: 'text',
	};

	if (classes[type]) {
		return classes[type];
	}

	return '';
}

// if the page body has a 'lede' (intro) paragraph,
// add a 'lede' class to the first passage that appears in the list of blocks
function getLedeClass(block: BlockType):string {
	if (showLedeStyle) {
		const firstPassage = sectionList[0].blocks.find((block: BlockType) => {
			return block.type === 'passage';
		});
		return (block === firstPassage) ? 'lede' : '';
	}
}

function sharedBlockFields(slice: Slice): BlockType {
	const {
		prominence,
		display_mode: displayMode = 'flow',
		include_in_excerpt: includeInExcerpt,
	} = slice.primary;

	return {
		displayMode,
		prominence: prominence as BlockType["prominence"],
		includeInExcerpt: Boolean(includeInExcerpt),
		type: camelCase(slice.slice_type),
	};
}

function heading(slice: Slice): BlockType {
	const { title1: title, level, subheading } = slice.primary;

	return {
		title: prismicHelpers.asText(title),
		level: level || 2,
		subheading,
		...sharedBlockFields(slice),
	};
}

// --- block types ---
function figure(slice: Slice): BlockType {
	const { image, caption, attribution } = slice.primary;

	return {
		source: image,
		attribution: attribution?.length > 0 && {
			markdown: prismicHelpers.asText(attribution),
		},
		caption: caption?.length > 0 && {
			markdown: prismicHelpers.asText(caption)
		},
		...sharedBlockFields(slice),
	};
}

function imageGallery(slice: Slice): BlockType {
	const {
		attribution,
		caption,
		column_size: columnSize,
	} = slice.primary;

	return {
		attribution: attribution && {
			markdown: attribution
		},
		caption: caption.length > 0 && {
			markdown: prismicHelpers.asText(caption)
		},
		columnSize,
		images: slice.items.map((item) => ({
			...item.image,
			device: item.device || 'None',
		})),
		...sharedBlockFields(slice),
	}
}

function billboard(slice: Slice): BlockType {
	const {
		cover_images_gutter: imagesGutter,
		title1,
		subtitle,
		call_to_action_label: label,
		call_to_action_link: link,
		description: prismicText,
	} = slice.primary;

	const images = slice.items.reduce((result, item) => {
		const {
			device = 'None',
			priority = '1',
			relative_size: relativeSize,
			cover_image: source,
		} = item;

		if ((source as ImageField).url === '') return result;

		result.push({
			device,
			priority,
			relativeSize,
			source,
		});
		return result;
	}, []);

	return {
		...sharedBlockFields(slice),
		images,
		imagesGutter,
		cta: {
			link,
			label,
		},
		description: {
			prismicText,
		},
		displayMode: 'slide',
		subtitle: prismicHelpers.asText(subtitle),
		title: prismicHelpers.asText(title1),
	}
}

function collage(slice: Slice): BlockType {
	const {
		caption,
		attribution,
		gutter,
	} = slice.primary;

	const images = slice.items.map((item) => {
		const {
			device = 'None',
			priority = '1',
			relative_size: relativeSize,
			image: source,
		} = item;

		return {
			device,
			priority,
			relativeSize,
			source,
		}
	});

	return {
		...sharedBlockFields(slice),
		gutter,
		images,
		attribution: attribution && {
			markdown: attribution
		},
		caption: caption.length > 0 && {
			markdown: prismicHelpers.asText(caption)
		},
	}
}

function passage(slice: Slice): BlockType {
	const {
		structured_text: prismicText,
		markdown,
	} = slice.primary;

	return {
		text: {
			prismicText,
			markdown: prismicHelpers.asText(markdown)
		},
		...sharedBlockFields(slice),
	};
}

function aside(slice: Slice): BlockType {
	const {
		structured_text: prismicText,
		markdown,
		label,
	} = slice.primary;

	return {
		label,
		text: {
			prismicText,
			markdown: prismicHelpers.asText(markdown)
		},
		...sharedBlockFields(slice),
	};
}

function blockQuote(slice: Slice): BlockType {
	const {
		structured_text: prismicText,
		markdown,
	} = slice.primary;

	slice.slice_type = 'blockQuote';

	return {
		text: {
			prismicText,
			markdown: prismicHelpers.asText(markdown)
		},
		...sharedBlockFields(slice),
	};
}

function table(slice: Slice): BlockType {
	const {
		csv_file: CSVFile,
		key_columns: keyColumns,
		footer,
	} = slice.primary;

	return {
		CSVFile: prismicHelpers.asLink(CSVFile),
		keyColumns,
		footer,
		...sharedBlockFields(slice),
	};
}

function feed(slice: Slice): BlockType {
	const {
		title,
		subtitle,
		call_to_action_label: label,
		call_to_action_link: link,
		description: prismicText,
		content_source: contentSource,
	} = slice.primary;

	return {
		...sharedBlockFields(slice),
		cta: {
			link,
			label,
		},
		contentSource,
		description: {
			prismicText,
		},
		displayMode: 'slide',
		subtitle: prismicHelpers.asText(subtitle),
		title: prismicHelpers.asText(title),
	}
}

// functions for each block type
const blockTypes = {
	'image_gallery': imageGallery,
	quote: blockQuote,
	aside,
	billboard,
	collage,
	feed,
	figure,
	heading,
	passage,
	table,
};

// --- build an array of blocks, sorted into sections ---
const sectionList = body.reduce((result: Array<any>, slice: Slice) => {
	const {
		slice_type: type,
		primary,
	} = slice;

	// if the block is a section, then add a new section to the array
	if (type === 'sectionStart') {
		result.push({
			uid: primary.uid,
			blocks: [],
		});
		return result;
	}

	// if the first blocks are outside a section, then make a generic/empty 'section'
	if (result.length === 0 && type !== 'sectionStart') {
		result.push({ blocks: [] });
	}

	// add the block object to the last 'section' array item
	// if it matches one of the available types
	if (blockTypes[type]) {
		const block = blockTypes[type](slice);
		result[result.length - 1].blocks.push(block);
	}
	return result;
}, []);

const classList = [
	'block-list',
	className
].join(' ');
---

<div class={classList}>
	{sectionList.map(({ uid, blocks }) => (
		uid
			? <section id={uid}>
					{blocks.map((block) => (
						<Block class={[
							getBlockClass(block.type),
							getLedeClass(block),
						].join(' ')} {block} />
					))}
				</section>
			: blocks.map((block) => (
				<Block class={[
					getBlockClass(block.type),
					getLedeClass(block),
				].join(' ')} {block} />
			))
	))}
</div>

<style>
	.block-list > :global(* + *) {
		padding-block-start: var(--space-wide);
	}

	.block-list :global(.heading + .text) {
		padding-top: var(--space-narrow);
	}

	/* when two sections of type follow one another, add "invisible" spacing between so they feel like one continuous flow of text */
	.block-list :global(.text + .text) {
		padding-top: var(--space-medium);
	}

	.lede :global(p:first-child) {
		font-size: var(--type-scale-delta);
		font-family: var(--type-font-display);
	}
</style>
