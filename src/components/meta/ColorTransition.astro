---
// --- utilities ---
import prismic from '@lib/prismic';
import { setThemeStyle } from '@lib/colorTheme';

// --- props ---
const {
	class: className,
	disabled = false,
	id,
	style,
	tag = 'div',
	name,
	hue,
	link,
} = Astro.props;

const El = tag;

const hasTheme = (name || hue || link) && true;

const classList = [
	'color-transition',
	!disabled && hasTheme ? 'is-active' : '',
	className || '',
].join(' ');

// --- helper functions ---

/**
 * Get values from the theme props (name, hue, and link)
 * and format them into a string of CSS props to pass to the ColorTheme component
 *
 * @returns {string}
 */
async function getThemeValues() {
	/**
	 * @typedef {object} ThemeData
	 * @property {string} name - name of a preset theme
	 * @property {number} hue - number of a base hue
	 * @property {string} link - ID of a Prismic doc with a theme to use here
	 */

	/** @type {ThemeData} */
	const theme = {};

	if (name) theme.name = name;
	if (hue) theme.hue = hue;

	if (link) {
		const { data } = await prismic.getByID(link);
		theme.custom = data.body1;
	}

	// return a style attr value only if theme props are defined for this component
	// - otherwise, this component can be 'invisible' and inherit the parent theme
	if (Object.keys(theme).length > 0) {
		return setThemeStyle({ ...theme });
	}
}
---

<El
	class={classList}
	data-theme={hasTheme && await getThemeValues()}
	{id}
	{style}
>
	<slot></slot>
</El>

<script>
	if ('IntersectionObserver' in window) {
		// the element (usually body) with a color theme applied
		// TODO what if there are multiple?
		const themeElement = document.querySelector('.theme');
		// Reference to the theme that exists when the page loads
		const originalTheme = themeElement.getAttribute('style');

		// all the elements on this page that trigger a color theme transition
		const transitionedElements = Array.from(document.querySelectorAll('.color-transition'));
		// the elements with a custom theme also have an 'active' class
		const transitionedElementsActive = transitionedElements.filter((el) => {
			return el.classList.contains('is-active');
		});

		const colorTransitionObserver = new IntersectionObserver(
			(entries) => {
				// transition the page color theme as elements become visible
				return entries.forEach((entry) => {
					// if the element is visible, update the .theme element's style property
					if (entry.isIntersecting) {
						console.log('intersecting')
						const { theme } = entry.target.dataset;

						if (theme) {
							themeElement.setAttribute('style', theme);
						} else {
							// restore the original page theme
							themeElement.setAttribute('style', originalTheme);
						}
					}
				});
			},
			{
				threshold: 0.5,
			}
		);

		if (transitionedElementsActive.length > 0) {
			transitionedElements.forEach((element) => {
				colorTransitionObserver.observe(element);
			})
		}
	}
</script>
